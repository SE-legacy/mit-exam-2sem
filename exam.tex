\documentclass[12pt]{article}

\usepackage {preamble}

\begin{document}

\author{}
\title{Материалы для подготовки к зачёту по СИТу 2025}
\date{}
\maketitle

\section{Linux}

\subsection{Базовые команды терминала UNIX"=подобных систем}
Основные команды, использующиеся в терминале Linux:
\begin{itemize}
\item \textit{touch <file>} "--- создать новый пустой файл;
\item \textit{mv <source> <destination>} "--- переместить/переименовать файл;
\item \textit{cp <source> <destination>} "--- скопировать файл;
\item \textit{rm <file>} "--- удалить файл;
\item \textit{cat <file>} "--- вывести содержимое файла на экран (если передать несколько файлов, cat их сконкатенирует и выведет);
\item \textit{less <file>} "--- пагинатор, позволяет вывести часть файла на экран и перелистывать его;
\item \textit{echo \glqq text\grqq} "--- вывод текста;
\item \textit{man <command>} "--- информация о команде (мануал);
\item \textit{ls} "--- вывести список файлов в текущей директории;
\item \textit{cd <directory>} "--- перейти в другую директорию;
\item \textit{mkdir <directory>} "--- создать новую директорию;
\item \textit{find} "--- найти файл;
\item \textit{grep} "--- найти строки, соответствующие определённому шаблону;
\item \textit{wc} "--- посчитать количество строк, слов и байт в файле;
\item \textit{history} "--- показать историю терминала, т.е. последние использованные команды;
\item \textit{lsblk} "--- список физических устройств (дисков);
\item \textit{mount} "--- монтирование файловых систем;
\item \textit{reboot} "--- перезагрузка;
\item \textit{shutdown} "--- выключение;
\item \textit{sl} "--- самая важная команда по моему мнению :)
\end{itemize}

\subsection{Понятие корневого каталога и домашней директории. Переменные среды. Переменная PATH}
Корневой каталог (/) в Linux "--- самый верхний уровень иерархии файловой системы. Как правило он содержит следующие директории:
\begin{itemize}
\item /bin "--- бинарные файлы;
\item /boot "--- файлы, необходимые для загрузки системы;
\item /dev "--- файлы устройств;
\item /etc "--- конфигурационные файлы;
\item /lib "--- системные библиотеки;
\item /mnt "--- примонтированные файловые системы;
\item /opt "--- дополнительные приложения;
\item /root "--- домашний каталог пользователя root;
\item /sys "--- системные файлы;
\item /tmp "--- временные файлы;
\item /var "--- логи и базы данных.
\end{itemize}

У каждого пользователя в системе есть домашняя директория, которая лежит на пути /home/<username>. <<.>> обозначает текущую директорию, <<..>> "--- родительскую директорию, <<$\sim$>> "--- домашнюю директорию, эти обозначения можно использовать для более компактного использования команды cd.

Чтобы создать переменную среды, используется команда \textit{export KEY=\glqq value\grqq}. Эта переменная сохранится только для текущего сеанса оболочки, чтобы она сохранилась после перезагрузки, нужно записать её в файл \textit{.bashrc}. Для вывода всех переменных, которые есть в системе, используется команда \textit{env}, а значение одной переменной можно посмотреть с помощью команды \textit{printenv <VARIABLE>} или \textit{echo \$VARIABLE}. Названия переменных являются чувствительными к регистру. Также важно, что значения всех переменных являются строками.

Переменная \$PATH содержит набор каталогов, где система ищет исполняемые файлы при запуске какой"=либо команды. Это избавляет от необходимости каждый раз вводить полный путь до исполняемого файла команды и позволяет использовать короткую запись.

\subsection{Флаги и аргументы при командах. Примеры наиболее важных флагов для базовых команд. Получение аргументов в скрипте}
Синтаксис команды обычно выглядит как <название команды> "=флаги [аргументы]. Флаги несколько изменяют работу самой команды, тогда как в качестве аргументов передаются данные, с которыми работает команда. Несколько примеров базовых флагов:
\begin{enumerate}
\item "=f ("="=force) "--- выполняет команду насильно, игнорируя предупреждения, может необратимо навредить файлам;
\item "=v ("="=verbose) "--- выводит все ошибки, предупреждения и логи;
\item "=h ("="=help) "--- выводит краткую справку о команде;
\item "=r "--- \textit{rm "=r} рекурсивно удаляет всю директорию;
\item "=a "--- \textit{ls "=a} выводит все файлы, в том числе скрытые;
\item "=j "--- \textit{zip "=j} не сохраняет иерархическую структуру файлов при архивации;
\item "=l "--- \textit{wc "=l} выводит только количество строк в файле.
\end{enumerate}

У большей части флагов есть короткое название из одной буквы, которое записывается через "=, и длинное название, которое записывается через "="= (исключение составляет команда find, у которой длинные аргументы записываются через один минус, например, \textit{find "=name}). Несколько коротких флагов можно объединять, например, "=f "=a "--- то же самое, что "=fa.

Чтобы получить аргументы внутри скрипта, нужно использовать синтаксис \$n, где n "--- номер аргумента. \$1, \$2, \dots "--- первый, второй и т.д. аргументы, \$0 "--- само название скрипта.

\subsection{Перенаправление вывода в файл и из файла. Понятие конвейера, примеры применения конвейеров}
Оператор > перенаправляет вывод команды в файл. Например, \textit{echo \glqq hello\grqq > output.txt}.

Оператор < перенаправляет ввод из файла. Например, \textit{wc "=l < input.txt}.

Конвейер обозначается символом | и передаёт данные из стандартного вывода одной команды на стандартный ввод другой. Конвейер удобно использовать в сочетании с инструментом xargs, который разбивает полученный ввод и передаёт его как аргументы команде. Например, \textit{find \dots | xargs cat} объединит и выведет все найденные файлы.

У команды find также есть специальный флаг "=exec, который работает аналогично конвейерам. Его синтаксис выглядит следующим образом: \textit{find \dots "=exec <название команды> \{куда подставить результат выполнения find\} $\backslash$; (+)}. <<$\backslash$;>> подставляет файлы по очереди ($\backslash$ экранирует точку с запятой от bash), <<+>> подставляет все файлы сразу.

\subsection{Небольшие практические задачи}
Найти все \textit{.cpp} файлы в домашней директории:
\inputminted{bash}{exam-findcpp.sh}

Посчитать строки в файле:
\inputminted{bash}{exam-countlines.sh}

\subsection{Стадии компиляции C/C++ кода. Команды компиляции на примере GCC. Системы сборки: что это и зачем они нужны}
Компиляция C/C++ кода состоит из следующих стадий:
\begin{enumerate}
\item Препроцессинг "--- подготовка кода к компиляции, работа с препроцессорными директивами: добавление \#include в код, замена макросов их значениями, удаление комментариев и т.д.
\item Компиляция "--- преобразование кода в ассемблерный код (создаётся ассемблерный файл \textit{.s}).
\item Ассемблирование "--- перевод ассемблерного кода в машинный (создаётся объектный файл \textit{.o}).
\item Линковка "--- связывание всех объектных файлов в один исполняемый (например, \textit{a.out}), который затем можно запустить с помощью команды \textit{./a.out}.
\end{enumerate}

GCC (GNU C Compiler) "--- компилятор языка Си, g++ "--- компилятор языка C++. Для того, чтобы скомпилировать файл, нужно использовать следующий синтаксис: \textit{gcc filename.c ("=o <название исполняемого файла>)}.

Системы сборки нужны для того, чтобы автоматизировать процесс компиляции, особенно когда проект состоит из большого количества файлов. Самой распространённой системой сборки является CMake, она генерирует makefile с набором инструкций, к которому затем применяется команда \textit{make}.

\section{Git}

\subsection{Базовые понятия в Git. Состояния файлов и команды, переводящие файлы между этими состояниями}
Git "--- система контроля версий. Чтобы создать git репозиторий в текущей директории, нужно использовать команду \textit{git init}.

Основные состояния файлов:
\begin{enumerate}
\item untracked "--- файл не отслеживается;
\item unmodified "--- файл не был изменён с момента последнего коммита;
\item modified "--- файл был отредактирован с момента последнего коммита;
\item staged "--- изменения в файле были зафиксированы и будут добавлены при выполнении коммита.
\end{enumerate}

Перевод файлов между состояниями:
\begin{itemize}
\item \textit{git add file} "--- untracked/modified $\rightarrow$ staged;
\item \textit{git commit "=m "message"} "--- staged $\rightarrow$ unmodified;
\item \textit{git rm file} "--- staged/modified/unmodified $\rightarrow$ untracked.
\end{itemize}

Для просмотра текущего состояния файлов используется команда \textit{git status}. Команда \textit{git diff} показывает внесённые изменения.

Чтобы избежать индексирования определённых файлов (например, временных или бинарных), их названия или маски можно добавить в файл \textit{.gitignore}. 

\subsection{Работа с удалённым репозиторием. Связывание локального репозитория с удалённым. Отправка изменений с локального в удалённый репозиторий. Получение изменений с удалённого репозитория. Форки}

Локальный репозиторий находится на своём компьютере, тогда как удалённый "--- на сервере (например, на GitHub).

Чтобы склонировать к себе удалённый репозиторий, можно использовать команду \textit{git clone url}. Чтобы добавить к себе удалённый репозиторий, используется команда \textit{git remote add name url}, флаг "=v (\textit{git remote "=v}) позволяет посмотреть все добавленные удалённые репозитории. После добавления к себе репозитория можно получать оттуда изменения с помощью команды \textit{git fetch name}. \textit{git pull} автоматически сливает изменения из удалённой ветки с текущей локальной.

Чтобы отправить изменения с локального в удалённый репозиторий, используется команда \textit{git push "=u name branch}. Флаг "=u в данном случае используется для создания в удалённом репозитории ветки, соответствующей локальной.

В публичные проекты как правило нельзя вносить изменения, поэтому можно с использованием веб"=интерфейса сделать форк репозитория, с которым уже можно будет работать в своём аккаунте, как с обычным удалённым репозиторием. Если Вы хотите, чтобы изменения были добавлены в оригинальный репозиторий, можно сделать pull request, который должен быть одобрен владельцем оригинального репозитория.

\subsection{Отмена внесённых ранее изменений. Откат репозитория ("="=soft, "="=hard варианты)}
Для отмены ранее внесённых изменений используются следующие две команды:
\begin{itemize}
\item \textit{git reset HEAD$\sim$n}, где n "--- число коммитов, на которое сбрасывается состояние указателя HEAD. У этой команды есть три режима:
	\begin{itemize}
	\item "="=soft "--- мягкий режим: изменения остаются в индексе и в рабочей директории, но удаляются из репозитория;
	\item "="=mixed "--- смешанный режим: изменения остаются в рабочей директории, но удаляются из репозитория и индекса;
	\item "="=hard "--- жёсткий режим: изменения полностью удаляются из репозитория, индекса и рабочей директории;
	\end{itemize}
\item \textit{git revert commit"=id} "--- откатывает изменения, создавая для этого новый коммит и не удаляя ошибочные коммиты из истории.
\end{itemize}

Чтобы изменить предыдущий коммит, например, добавить в него дополнительные файлы или изменить сообщение коммита, используется команда \textit{git commit "="=amend}.

\subsection{Работа с ветками в Git. Просмотр всех веток, создание, переключение локального репозитория на конкретную ветку. Объединение веток, возможные проблемы при этом}
В репозитории Git может быть несколько веток помимо основной, которая обычно называется main или master. Основные команды для работы с ветками и их флаги:
\begin{itemize}
\item \textit{git branch} "--- список локальных веток;
\item \textit{git branch "=r} "--- список удалённых веток;
\item \textit{git branch "=a} "--- список всех веток (локальных и удалённых);
\item \textit{git branch branch"=name} "--- создание новой ветки с названием branch"=name;
\item \textit{git checkout branch"=name} "--- переключиться на ветку с названием branch"=name;
\item \textit{git checkout "=b branch"=name} "--- создать новую ветку и сразу переключиться на неё.
\end{itemize}

Чтобы объединить некоторую ветку с данной, используется команда \textit{git merge}. При объединении веток могут возникнуть так называемые merge"=конфликты, когда изменения в ветках противоречат друг другу. Такие конфликты решаются вручную, если же их не возникает, слияние происходит автоматически.

Для объединения изменений двух веток с сохранением линейности истории можно также использовать команду \textit{git rebase}.

\subsection{Сохранение изменений в буфер (<<копилку>>). Основные команды, возможное применение}
Для сохранения изменений в буфер используется команда \textit{git stash}. Она сохраняет (<<прячет>>) неподтверждённые изменения (индексированные и неиндексированные) в отдельном хранилище, чтобы к ним можно было вернуться позже. Эта команда может быть полезна, например, для внесения срочных правок в другой ветке.
\begin{itemize}
\item \textit{git stash} "--- <<прячет>> внесённые изменения;
\item \textit{git stash pop} "--- убирает изменения из хранилища и применяет их к рабочей копии;
\item \textit{git stash apply} "--- применяет изменения к рабочей копии, но оставляет их и в хранилище.
\end{itemize}

\section{\LaTeX}

\subsection{Понятие класса документа. Примеры классов документов}
На тип документа указывает команда \verb|\documentclass{}|.
Основные типы документов:
\begin{itemize}
\item article "--- для оформления статей;
\item book "--- для оформления книг;
\item letter "--- для оформления писем;
\item beamer "--- для оформления презентаций;
\item CSWorks "--- для оформления научных работ на факультете КНиИТ.
\end{itemize}

У команды \verb|\documentclass| есть параметры, которые указываются в квадратных скобках до фигурных скобок. Основные параметры:
\begin{itemize}
\item размер шрифта (10 pt, 12pt, 14pt) "--- по умолчанию 10pt;
\item тип бумаги (a4paper, letterpaper) "--- по умолчанию letterpaper;
\item нужна ли пустая страница после титульного листа (titlepage, notitlepage) "--- для article по умолчанию notitlepage;
\item тип печати (oneside, twoside);
\item количество колонок (onecolumn, twocolumn).
\end{itemize}

\subsection{Понятие преамбулы документа, подключение пакетов. Основные пакеты для базовой компиляции документа на русском языке}
Сам документ заключён между командами \verb|\begin{document}| и \verb|\end{document}|, которые называются окружением. Перед началом окружения располагается преамбула, которая задаёт правила форматирования и другие настройки. Пакеты подключаются с помощью команды \verb|\usepackage|. Можно вынести преамбулу в отдельный файл \textit{preamble.sty} и подключить его из основного файла командой \verb|\usepackage{preamble}|. Для отображения русского языка необходимо подключить следующие три пакета:
\inputminted{tex}{russian.sty}

\subsection{Секционирование документа (основные команды). Взаимодействие секционирования с результатом выполнения команды tableofcontents. Структурирование документа (разделение на поддокументы с последующей компиляцией воедино). Хорошие практики при структурировании документа}
Чтобы соблюдать логические границы между различными частями документа, существует секционирование, то есть разделение документа на секции. Имеет место вложенность вида: глава (только для книги) $\rightarrow$ секция $\rightarrow$ подсекция $\rightarrow$ подподсекция. Используются следующие обозначения:
\begin{itemize}
\item \verb|\chapter{}| "--- глава, где в фигурных скобках при необходимости пишется название;
\item \verb|\chapter*{}| "--- глава, которой не присваивается номер (без названия не имеет смысла);
\item \verb|\section(*){}| "--- секция, которой присваивается (соотв. не присваивается) номер;
\item \verb|\subsection(*){}| "--- подсекция, которой присваивается (соотв. не присваивается) номер;
\item \verb|\subsubsection(*){}| "--- подподсекция, которой присваивается (соотв. не присваивается) номер.
\end{itemize}

Создание новой секции в статье или главы в книге автоматически заканчивает текущую и начинает новую страницу.

В документе можно создать содержание, куда автоматически включаются нумерованные главы, секции и подсекции, с помощью команды \verb|\tableofcontents|.

Хорошей практикой является разделение документа на поддокументы. Для этого части документа сохраняются в отдельные файлы, а затем подключаются с помощью команды \verb|\input{}|, где в фигурных скобках указывается название файла и путь к нему, если он лежит не в текущей директории. Если подключаемый файл имеет формат \textit{.tex}, то содержимое этого файла будет предварительно скомпилировано.

\subsection{Форматирование текста. Базовые команды для оформления знаков препинания: тире, дефиса, кавычек. Команды для оформления жирного и курсивного шрифтов}
Абзацы отделяются друг от друга пустой строкой, перенос на новую строку осуществляют команды \verb|\newline| и \verb|\\|, перенос на новую страницу "--- \verb|\newpage|.

После разделительных знаков препинания, но не перед ними, ставится пробел; скобки с обеих сторон выделяются пробелами, вокруг дефиса пробелы не ставятся. Некоторые знаки препинания записываются особым образом:
\begin{itemize}
\item тире: \verb|"---| или \verb|~---|;
\item числовые интервалы: \verb|--|;
\item дефис: \verb|"=|;
\item кавычки"=ёлочки: \verb|<<text>>|.
\end{itemize}

Существуют команды, изменяющие размер шрифта:
\begin{itemize}
\item \verb|\tiny| (5pt);
\item \verb|\scriptsize| (7pt);
\item \verb|\footnotesize| (8pt);
\item \verb|\small| (9pt);
\item \verb|\normalsize| (10pt);
\item \verb|\large| (12pt);
\item \verb|\Large| (14pt);
\item \verb|\LARGE| (17pt);
\item \verb|\huge| (20 pt);
\item \verb|\Huge| (25pt).
\end{itemize}

\textbf{Жирный} шрифт оформляется с помощью команды \verb|\textbf|, а \textit{курсив} "--- с помощью команды \verb|\textit|. Команда \verb~\verb|command|~ позволяет вставить в документ команду \LaTeX~без её выполнения. Окружения flushleft, center и flushright обеспечивают выравнивание по левому краю, по центру и по правому краю соответственно.

\subsection{Понятие списка. Виды списков, оформление вложенных списков}
Список "--- перечисление элементов. Если элементы списка представляют собой целые предложения, то в конце каждого элемента обычно ставится точка, если же это слова или словосочетания, они разделяются точками с запятой. Элементы списка разделяются с помощью команды \verb|\item|. 
	
Существует три вида окружения для списков:
\begin{itemize}
\item \verb|\begin{itemize} \end{itemize}| "--- создаёт ненумерованный список;
\item \verb|\begin{enumerate} \end{enumerate}| "--- создаёт нумерованный список;
\item \verb|\begin{description} \end{description}| "--- создаёт список"=описание (в таком случае каждый элемент начинается как \verb|\item[заголовок элемента]|.
\end{itemize}

\subsection{Понятие математического окружения. Синтаксис. Встроенные формулы и выносные формулы. Особенности математического окружения: работа с отступами, кириллицей}
Для того, чтобы оформлять математические формулы, в \LaTeX~есть математическое окружение. Существует два типа формул: встроенные и выносные.

Встроенные формулы располагаются внутри текста, они выглядят как команды, заключённые в два знака \$ (\verb|$equation$|).

Для выносных формул можно использовать окружение \verb|\begin{equation} \end{equation}| (для нумерованных формул) или \verb|\begin{equation*} \end{equation*}| (для ненумерованных формул). Окружение \verb|\begin{align} \end{align}| позволяет выравнивать длинные формулы.

Верхний индекс обозначается с помощью символа $\wedge$, а нижний "--- с помощью символа \_. Индексы из нескольких символов заключаются в фигурные скобки.

Знак умножения ставится с помощью команды \verb|\cdot|, дробь записывается как \verb|\frac{}{}|. Знаки сравнения записываются как \verb|\le| ($\le$), \verb|\leqslant| ($\leqslant$), \verb|\ge| ($\ge$), \verb|\geqslant| ($\geqslant$), \verb|\ne| ($\ne$).

Некоторые примеры команд математического окружения:
\begin{itemize}
\item Греческие буквы: \verb|\alpha| ($\alpha$), \verb|\epsilon| ($\epsilon$), \verb|\varepsilon| ($\varepsilon$);
\item Сумма, произведение, интеграл: \verb|\sum| ($\sum$), \verb|\prod| ($\prod$), \verb|\int| ($\int$);
\item Корень n"=ной степени: \verb|\sqrt[n]{}| ($\sqrt[3]{x}$).
\end{itemize}

Чтобы в математическом режиме отображался текст, его нужно оборачивать в команду \verb|$\text{}$|, для отображения пробелов применяется тильда $\sim$.

\subsection{Работа со сложными объектами. Базовые команды для создания матриц, таблиц, систем уравнений. Синтаксис}

Для создания матриц используются следующие окружения:
\begin{itemize}
\item \verb|\begin{matrix} \end{matrix}| "--- матрица без скобок;
\item \verb|\begin{bmatrix} \end{bmatrix}| "--- матрица в квадратных скобках [ ];
\item \verb|\begin{pmatrix} \end{pmatrix}| "--- матрица в круглых скобках ( );
\item \verb|\begin{vmatrix} \end{vmatrix}| "--- матрица в прямых скобках |  |;
\item \verb|\begin{Bmatrix} \end{Bmatrix}| "--- матрица в фигурных скобках \{ \};
\item \verb|\begin{Vmatrix} \end{Vmatrix}| "--- матрица в двойных прямых скобках ||  ||.
\end{itemize}

Элементы матрицы в рамках одной строки разделяются символом \&, а строки матрицы "--- символом \verb|\\|.

Простая таблица создаётся с помощью окружения \verb|\begin{tabular} \end{tabular}|, если нужна подпись и ссылка, используется окружение \verb|\begin{table} \end{table}|. Разделение элементов выполняется так же, как в матрице.

Для создания систем уравнений применяется окружение \verb|\begin{cases} \end{cases}|.

\section{Работа с программным кодом. Аргументы команд пакета minted или Verbatim (fancyvrb). Основные опциональные параметры}
Для вставки кода можно использовать пакет minted, который подключается с помощью команды \verb|\usepackage{minted}|. Когда код пишется в теле документа, он выделяется с помощью команды \verb|\begin{minted}[options]{language} \end{minted}|, а для подключения кода из отдельного файла используется синтаксис \verb|\inputminted[options]{language}{filename}|.
Основные опциональные параметры:
\begin{itemize}
\item frame=lines/leftline/topline/bottomline "--- рисует линии вокруг кода, чтобы выделить его;
\item framesep=2mm/pt "--- дистанция между текстом и окружением кода;
\item baselinestretch "--- дистанция между строками;
\item bgcolor "--- цвет фона;
\item fontsize "--- размер шрифта;
\item style=bw "--- установка чёрно"=белого стиля кода;
\item breaklines "--- перенос длинных строк;
\item linenos "--- включение отображения номеров строк.
\end{itemize}

\section{Вставка изображений. Окружение figure, позиционирование плавающих объектов. Масштабирование изображений}
Плавающие объекты вставляются с помощью окружения \verb|\begin{figure} \end{figure}|. Внутри этого окружения существует команда для центрирования объекта \verb|\centering|, а также параметры, отвечающие за то, как объект будет вставлен в документ:
\begin{itemize}
\item h "--- вставка на месте, т.е. ближе всего к реальному расположению объекта в документе;
\item H "--- вставка \textbf{ровно} на том месте, где объект указан в документе;
\item t (b) "--- вставка вверху (внизу) страницы;
\item p "--- вставка на специальной странице для плавающих объектов;
\item ! "--- попытаться перегрузить внутренние параметры \LaTeX, чтобы определить <<хорошую>> позицию.
\end{itemize}

Рисунки вставляются командой \verb|\includegraphics[options]{file}|. Для изменения относительного размера изображения используется параметр scale. Если он равен $1.0$, изображение не изменит масштаб, если он равен $2.0$ "--- увеличится в 2 раза, $0.5$ "--- уменьшится в 2 раза. Команда \verb|\caption| вставляет подпись к рисунку.

\end{document}
